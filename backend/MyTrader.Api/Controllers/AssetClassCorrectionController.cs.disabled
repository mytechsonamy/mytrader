using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using MyTrader.Core.DTOs;
using MyTrader.Core.Services.ETL;
using MyTrader.Infrastructure.Monitoring;
using System.ComponentModel.DataAnnotations;

namespace MyTrader.Api.Controllers;

/// <summary>
/// Production-grade AssetClass Correction ETL Controller
/// Provides comprehensive batch processing operations with operational monitoring
/// and enterprise-grade reliability features
/// </summary>
[ApiController]
[Route("api/etl/asset-class-correction")]
// [Authorize] // Temporarily disabled for testing - Enable in production
public class AssetClassCorrectionController : ControllerBase
{
    private readonly IMarketDataAssetClassCorrectionService _correctionService;
    private readonly AssetClassCorrectionMonitor _monitor;
    private readonly ILogger<AssetClassCorrectionController> _logger;

    public AssetClassCorrectionController(
        IMarketDataAssetClassCorrectionService correctionService,
        AssetClassCorrectionMonitor monitor,
        ILogger<AssetClassCorrectionController> logger)
    {
        _correctionService = correctionService;
        _monitor = monitor;
        _logger = logger;
    }

    /// <summary>
    /// Execute AssetClass correction with comprehensive batch processing
    /// </summary>
    /// <param name="options">Correction options for batch processing configuration</param>
    /// <param name="cancellationToken">Cancellation token for operation control</param>
    /// <returns>Detailed correction results with operational metrics</returns>
    [HttpPost("execute")]
    [ProducesResponseType(typeof(ApiResponse<AssetClassCorrectionResult>), 200)]
    [ProducesResponseType(typeof(ApiResponse<string>), 400)]
    [ProducesResponseType(typeof(ApiResponse<string>), 409)] // Conflict - operation already running
    [ProducesResponseType(typeof(ApiResponse<string>), 500)]
    public async Task<ActionResult<ApiResponse<AssetClassCorrectionResult>>> ExecuteCorrectionAsync(
        [FromBody] AssetClassCorrectionOptions? options = null,
        CancellationToken cancellationToken = default)
    {
        var operationId = Guid.NewGuid().ToString();

        try
        {
            _logger.LogInformation("AssetClass correction requested via API. Operation ID: {OperationId}", operationId);

            // Check if another operation is already running
            var currentStatus = await _correctionService.GetCorrectionStatusAsync(cancellationToken);
            if (currentStatus.IsRunning)
            {
                _logger.LogWarning("AssetClass correction already in progress: {CurrentOperationId}",
                    currentStatus.CurrentOperationId);

                return Conflict(ApiResponse<string>.Error(
                    "Another AssetClass correction operation is already running. " +
                    $"Current operation: {currentStatus.CurrentOperationId}",
                    "OPERATION_IN_PROGRESS"));
            }

            // Validate options
            options ??= new AssetClassCorrectionOptions();
            var validationResult = ValidateOptions(options);
            if (validationResult != null)
            {
                return BadRequest(ApiResponse<string>.Error(validationResult, "INVALID_OPTIONS"));
            }

            // Start monitoring
            _monitor.TrackOperationStart(operationId, options);

            // Execute the correction operation
            var result = await _correctionService.ExecuteAssetClassCorrectionAsync(options, cancellationToken);

            // Track completion
            _monitor.TrackOperationCompletion(result);

            if (result.Success)
            {
                _logger.LogInformation("AssetClass correction completed successfully: {OperationId}. " +
                    "Records processed: {Processed}, Duration: {Duration}",
                    result.CorrectionId, result.RecordsSuccessfullyProcessed, result.Duration);

                return Ok(ApiResponse<AssetClassCorrectionResult>.Success(
                    result,
                    $"AssetClass correction completed successfully. {result.RecordsSuccessfullyProcessed} records processed."));
            }
            else
            {
                _logger.LogError("AssetClass correction failed: {OperationId}. Error: {Error}",
                    result.CorrectionId, result.ErrorMessage);

                return Ok(ApiResponse<AssetClassCorrectionResult>.Error(
                    result.ErrorMessage ?? "Correction operation failed",
                    "CORRECTION_FAILED",
                    result)); // Still return result for debugging
            }
        }
        catch (OperationCanceledException)
        {
            _logger.LogWarning("AssetClass correction operation cancelled: {OperationId}", operationId);
            return BadRequest(ApiResponse<string>.Error("Operation was cancelled", "OPERATION_CANCELLED"));
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unexpected error during AssetClass correction: {OperationId}", operationId);
            return StatusCode(500, ApiResponse<string>.Error(
                "An unexpected error occurred during the correction operation",
                "INTERNAL_SERVER_ERROR"));
        }
    }

    /// <summary>
    /// Analyze current AssetClass data integrity without making changes
    /// </summary>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>Comprehensive integrity analysis report</returns>
    [HttpGet("analyze")]
    [ProducesResponseType(typeof(ApiResponse<AssetClassIntegrityReport>), 200)]
    [ProducesResponseType(typeof(ApiResponse<string>), 500)]
    public async Task<ActionResult<ApiResponse<AssetClassIntegrityReport>>> AnalyzeIntegrityAsync(
        CancellationToken cancellationToken = default)
    {
        try
        {
            _logger.LogInformation("AssetClass integrity analysis requested via API");

            var report = await _correctionService.AnalyzeAssetClassIntegrityAsync(cancellationToken);

            // Track analysis for monitoring
            _monitor.TrackIntegrityAnalysis(report);

            _logger.LogInformation("Integrity analysis completed. Completeness: {Completeness:F2}%, " +
                "Records needing correction: {NeedingCorrection}",
                report.AssetClassCompleteness,
                report.RecordsWithNullAssetClass + report.RecordsWithEmptyAssetClass);

            return Ok(ApiResponse<AssetClassIntegrityReport>.Success(
                report,
                $"Integrity analysis completed. {report.RecordsWithNullAssetClass + report.RecordsWithEmptyAssetClass} records need correction."));
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error during integrity analysis");
            return StatusCode(500, ApiResponse<string>.Error(
                "An error occurred during integrity analysis",
                "ANALYSIS_ERROR"));
        }
    }

    /// <summary>
    /// Preview what corrections would be made without executing them
    /// </summary>
    /// <param name="options">Preview options</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>Preview of proposed corrections and identified risks</returns>
    [HttpPost("preview")]
    [ProducesResponseType(typeof(ApiResponse<AssetClassCorrectionPreview>), 200)]
    [ProducesResponseType(typeof(ApiResponse<string>), 400)]
    [ProducesResponseType(typeof(ApiResponse<string>), 500)]
    public async Task<ActionResult<ApiResponse<AssetClassCorrectionPreview>>> PreviewCorrectionsAsync(
        [FromBody] AssetClassCorrectionOptions? options = null,
        CancellationToken cancellationToken = default)
    {
        try
        {
            _logger.LogInformation("AssetClass correction preview requested via API");

            options ??= new AssetClassCorrectionOptions();
            var validationResult = ValidateOptions(options);
            if (validationResult != null)
            {
                return BadRequest(ApiResponse<string>.Error(validationResult, "INVALID_OPTIONS"));
            }

            var preview = await _correctionService.PreviewCorrectionsAsync(options, cancellationToken);

            _logger.LogInformation("Correction preview generated. Estimated records: {EstimatedRecords}, " +
                "Risks identified: {RiskCount}",
                preview.EstimatedRecordsToProcess, preview.IdentifiedRisks.Count);

            return Ok(ApiResponse<AssetClassCorrectionPreview>.Success(
                preview,
                $"Preview generated for {preview.EstimatedRecordsToProcess} records with {preview.IdentifiedRisks.Count} risks identified."));
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error generating correction preview");
            return StatusCode(500, ApiResponse<string>.Error(
                "An error occurred while generating the preview",
                "PREVIEW_ERROR"));
        }
    }

    /// <summary>
    /// Validate corrections after they have been applied
    /// </summary>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>Validation results with data quality metrics</returns>
    [HttpPost("validate")]
    [ProducesResponseType(typeof(ApiResponse<AssetClassValidationResult>), 200)]
    [ProducesResponseType(typeof(ApiResponse<string>), 500)]
    public async Task<ActionResult<ApiResponse<AssetClassValidationResult>>> ValidateCorrectionsAsync(
        CancellationToken cancellationToken = default)
    {
        try
        {
            _logger.LogInformation("AssetClass validation requested via API");

            var validationResult = await _correctionService.ValidateCorrectionsAsync(cancellationToken);

            _logger.LogInformation("Validation completed. Passed: {Passed}, Errors: {ErrorCount}, " +
                "Quality Score: {QualityScore:F2}%",
                validationResult.ValidationPassed, validationResult.ValidationErrors,
                validationResult.DataQualityScore);

            var message = validationResult.ValidationPassed
                ? $"Validation passed with quality score of {validationResult.DataQualityScore:F2}%"
                : $"Validation found {validationResult.ValidationErrors} issues";

            return Ok(ApiResponse<AssetClassValidationResult>.Success(validationResult, message));
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error during validation");
            return StatusCode(500, ApiResponse<string>.Error(
                "An error occurred during validation",
                "VALIDATION_ERROR"));
        }
    }

    /// <summary>
    /// Get current status of correction operations
    /// </summary>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>Current status including progress and recent operations</returns>
    [HttpGet("status")]
    [ProducesResponseType(typeof(ApiResponse<AssetClassCorrectionStatus>), 200)]
    [ProducesResponseType(typeof(ApiResponse<string>), 500)]
    public async Task<ActionResult<ApiResponse<AssetClassCorrectionStatus>>> GetStatusAsync(
        CancellationToken cancellationToken = default)
    {
        try
        {
            var status = await _correctionService.GetCorrectionStatusAsync(cancellationToken);

            return Ok(ApiResponse<AssetClassCorrectionStatus>.Success(
                status,
                status.IsRunning ? $"Operation in progress: {status.CurrentOperationId}" : "No operation running"));
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving correction status");
            return StatusCode(500, ApiResponse<string>.Error(
                "An error occurred while retrieving status",
                "STATUS_ERROR"));
        }
    }

    /// <summary>
    /// Rollback the last correction operation using backup data
    /// </summary>
    /// <param name="request">Rollback request with correction ID</param>
    /// <param name="cancellationToken">Cancellation token</param>
    /// <returns>Rollback operation results</returns>
    [HttpPost("rollback")]
    [ProducesResponseType(typeof(ApiResponse<AssetClassRollbackResult>), 200)]
    [ProducesResponseType(typeof(ApiResponse<string>), 400)]
    [ProducesResponseType(typeof(ApiResponse<string>), 404)]
    [ProducesResponseType(typeof(ApiResponse<string>), 500)]
    public async Task<ActionResult<ApiResponse<AssetClassRollbackResult>>> RollbackCorrectionAsync(
        [FromBody] RollbackRequest request,
        CancellationToken cancellationToken = default)
    {
        try
        {
            if (string.IsNullOrEmpty(request.CorrectionId))
            {
                return BadRequest(ApiResponse<string>.Error(
                    "CorrectionId is required for rollback",
                    "MISSING_CORRECTION_ID"));
            }

            _logger.LogWarning("Rollback requested for correction: {CorrectionId}", request.CorrectionId);

            var rollbackResult = await _correctionService.RollbackLastCorrectionAsync(
                request.CorrectionId, cancellationToken);

            if (rollbackResult.Success)
            {
                _logger.LogInformation("Rollback completed successfully: {CorrectionId}. " +
                    "Records rolled back: {RecordsRolledBack}",
                    request.CorrectionId, rollbackResult.RecordsRolledBack);

                return Ok(ApiResponse<AssetClassRollbackResult>.Success(
                    rollbackResult,
                    $"Rollback completed successfully. {rollbackResult.RecordsRolledBack} records restored."));
            }
            else
            {
                _logger.LogError("Rollback failed for {CorrectionId}: {Error}",
                    request.CorrectionId, rollbackResult.ErrorMessage);

                if (rollbackResult.ErrorMessage?.Contains("not found") == true)
                {
                    return NotFound(ApiResponse<string>.Error(
                        rollbackResult.ErrorMessage,
                        "CORRECTION_NOT_FOUND"));
                }

                return BadRequest(ApiResponse<AssetClassRollbackResult>.Error(
                    rollbackResult.ErrorMessage ?? "Rollback failed",
                    "ROLLBACK_FAILED",
                    rollbackResult));
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error during rollback operation for {CorrectionId}", request.CorrectionId);
            return StatusCode(500, ApiResponse<string>.Error(
                "An unexpected error occurred during rollback",
                "ROLLBACK_ERROR"));
        }
    }

    /// <summary>
    /// Get health status for operational monitoring
    /// </summary>
    /// <returns>Health check results for monitoring systems</returns>
    [HttpGet("health")]
    [ProducesResponseType(typeof(ApiResponse<AssetClassCorrectionHealthStatus>), 200)]
    [ProducesResponseType(typeof(ApiResponse<string>), 503)] // Service Unavailable
    public ActionResult<ApiResponse<AssetClassCorrectionHealthStatus>> GetHealthStatus()
    {
        try
        {
            var healthStatus = _monitor.GetHealthStatus();

            if (healthStatus.IsHealthy)
            {
                return Ok(ApiResponse<AssetClassCorrectionHealthStatus>.Success(
                    healthStatus, "Service is healthy"));
            }
            else
            {
                return StatusCode(503, ApiResponse<AssetClassCorrectionHealthStatus>.Error(
                    "Service is experiencing issues",
                    "SERVICE_DEGRADED",
                    healthStatus));
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving health status");
            return StatusCode(503, ApiResponse<string>.Error(
                "Health check failed",
                "HEALTH_CHECK_ERROR"));
        }
    }

    /// <summary>
    /// Get operational metrics for monitoring dashboards
    /// </summary>
    /// <returns>Current operational metrics</returns>
    [HttpGet("metrics")]
    [ProducesResponseType(typeof(ApiResponse<Dictionary<string, object>>), 200)]
    public ActionResult<ApiResponse<Dictionary<string, object>>> GetMetrics()
    {
        try
        {
            var metrics = new Dictionary<string, object>
            {
                ["service_name"] = "AssetClass Correction ETL",
                ["version"] = "1.0.0",
                ["timestamp"] = DateTime.UtcNow,
                ["status"] = "operational"
            };

            // Add health status metrics
            var healthStatus = _monitor.GetHealthStatus();
            metrics["health_status"] = healthStatus.OverallStatus;
            metrics["components_healthy"] = healthStatus.Components.Values.Count(c => c.IsHealthy);
            metrics["components_total"] = healthStatus.Components.Count;

            return Ok(ApiResponse<Dictionary<string, object>>.Success(
                metrics, "Operational metrics retrieved successfully"));
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving metrics");
            return StatusCode(500, ApiResponse<string>.Error(
                "Failed to retrieve metrics",
                "METRICS_ERROR"));
        }
    }

    #region Private Helper Methods

    private string? ValidateOptions(AssetClassCorrectionOptions options)
    {
        if (options.BatchSize <= 0 || options.BatchSize > 10000)
        {
            return "BatchSize must be between 1 and 10,000";
        }

        if (options.MaxRecordsToProcess.HasValue && options.MaxRecordsToProcess <= 0)
        {
            return "MaxRecordsToProcess must be greater than 0";
        }

        if (options.Timeout.TotalMinutes < 1 || options.Timeout.TotalHours > 24)
        {
            return "Timeout must be between 1 minute and 24 hours";
        }

        if (options.RetryConfig.MaxRetries < 0 || options.RetryConfig.MaxRetries > 10)
        {
            return "MaxRetries must be between 0 and 10";
        }

        if (options.TargetSymbols?.Any(s => string.IsNullOrWhiteSpace(s)) == true)
        {
            return "TargetSymbols cannot contain null or empty values";
        }

        return null; // Valid
    }

    #endregion
}

/// <summary>
/// Request model for rollback operations
/// </summary>
public class RollbackRequest
{
    /// <summary>
    /// ID of the correction operation to rollback
    /// </summary>
    [Required]
    [StringLength(100, MinimumLength = 1)]
    public string CorrectionId { get; set; } = string.Empty;

    /// <summary>
    /// Optional reason for the rollback
    /// </summary>
    [StringLength(500)]
    public string? Reason { get; set; }

    /// <summary>
    /// Whether to validate the rollback operation
    /// </summary>
    public bool ValidateAfterRollback { get; set; } = true;
}