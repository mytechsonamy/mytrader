<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Performance & Core Web Vitals Test</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
        .container { max-width: 1400px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .test-section { margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 5px; background: #fafafa; }
        .result { margin: 10px 0; padding: 10px; border-radius: 3px; border-left: 4px solid; }
        .success { background: #d4edda; border-color: #28a745; color: #155724; }
        .error { background: #f8d7da; border-color: #dc3545; color: #721c24; }
        .warning { background: #fff3cd; border-color: #ffc107; color: #856404; }
        .info { background: #d1ecf1; border-color: #17a2b8; color: #0c5460; }
        .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin: 20px 0; }
        .metric-card { background: white; padding: 15px; border-radius: 8px; border: 1px solid #ddd; text-align: center; }
        .metric-value { font-size: 28px; font-weight: bold; margin: 10px 0; }
        .metric-label { font-size: 14px; color: #6c757d; margin-bottom: 5px; }
        .metric-description { font-size: 12px; color: #6c757d; margin-top: 5px; }
        .excellent { color: #28a745; }
        .good { color: #6f42c1; }
        .needs-improvement { color: #ffc107; }
        .poor { color: #dc3545; }
        .performance-gauge { width: 100px; height: 100px; margin: 10px auto; position: relative; }
        .gauge-bg { width: 100%; height: 100%; border-radius: 50%; background: conic-gradient(from 0deg, #dc3545 0deg 90deg, #ffc107 90deg 180deg, #28a745 180deg 360deg); }
        .gauge-inner { position: absolute; top: 10px; left: 10px; width: 80px; height: 80px; background: white; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; }
        button { margin: 5px; padding: 10px 15px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; }
        button:hover { background: #0056b3; }
        button:disabled { background: #6c757d; cursor: not-allowed; }
        .test-progress { background: #e9ecef; border-radius: 10px; padding: 3px; margin: 10px 0; }
        .progress-bar { background: #007bff; height: 20px; border-radius: 8px; transition: width 0.3s ease; }
        .iframe-container { border: 2px solid #ddd; border-radius: 4px; margin: 20px 0; }
        .iframe-container iframe { width: 100%; border: none; height: 600px; }
        pre { background: #f1f3f4; padding: 10px; border-radius: 3px; overflow-x: auto; font-size: 12px; max-height: 200px; overflow-y: auto; }
        .lighthouse-score { font-size: 48px; font-weight: bold; margin: 10px 0; }
        .vitals-summary { display: flex; justify-content: space-around; margin: 20px 0; }
        .vital { text-align: center; padding: 10px; border-radius: 8px; background: white; }
    </style>
</head>
<body>
    <div class="container">
        <h1>‚ö° Performance & Core Web Vitals Test</h1>
        <p>Comprehensive performance testing including Core Web Vitals, load times, and resource optimization</p>

        <!-- Test Progress -->
        <div class="test-section">
            <h2>üìä Test Progress</h2>
            <div class="test-progress">
                <div class="progress-bar" id="progressBar" style="width: 0%"></div>
            </div>
            <div id="currentTest">Ready to start performance tests</div>
        </div>

        <!-- Core Web Vitals -->
        <div class="test-section">
            <h2>üéØ Core Web Vitals</h2>
            <div class="vitals-summary">
                <div class="vital">
                    <div class="metric-label">Largest Contentful Paint (LCP)</div>
                    <div id="lcpValue" class="metric-value">-</div>
                    <div id="lcpStatus" class="metric-description">Not measured</div>
                </div>
                <div class="vital">
                    <div class="metric-label">First Input Delay (FID)</div>
                    <div id="fidValue" class="metric-value">-</div>
                    <div id="fidStatus" class="metric-description">Not measured</div>
                </div>
                <div class="vital">
                    <div class="metric-label">Cumulative Layout Shift (CLS)</div>
                    <div id="clsValue" class="metric-value">-</div>
                    <div id="clsStatus" class="metric-description">Not measured</div>
                </div>
            </div>
            <button onclick="measureCoreWebVitals()">üìè Measure Core Web Vitals</button>
        </div>

        <!-- Performance Metrics -->
        <div class="test-section">
            <h2>üìà Performance Metrics</h2>
            <div class="grid">
                <div class="metric-card">
                    <div class="metric-label">Overall Performance Score</div>
                    <div class="performance-gauge">
                        <div class="gauge-bg"></div>
                        <div class="gauge-inner" id="performanceScore">-</div>
                    </div>
                    <div class="metric-description">Lighthouse-style scoring</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Page Load Time</div>
                    <div id="loadTime" class="metric-value">-</div>
                    <div class="metric-description">Time to fully load</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">DOM Ready Time</div>
                    <div id="domReady" class="metric-value">-</div>
                    <div class="metric-description">Time to DOM interactive</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">First Paint</div>
                    <div id="firstPaint" class="metric-value">-</div>
                    <div class="metric-description">Time to first visual change</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Time to Interactive</div>
                    <div id="timeToInteractive" class="metric-value">-</div>
                    <div class="metric-description">Time until fully interactive</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Bundle Size</div>
                    <div id="bundleSize" class="metric-value">-</div>
                    <div class="metric-description">Total JavaScript size</div>
                </div>
            </div>
        </div>

        <!-- Resource Performance -->
        <div class="test-section">
            <h2>üì¶ Resource Performance</h2>
            <div class="grid">
                <div class="metric-card">
                    <div class="metric-label">Total Resources</div>
                    <div id="totalResources" class="metric-value">-</div>
                    <div class="metric-description">Files loaded</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Total Transfer Size</div>
                    <div id="totalSize" class="metric-value">-</div>
                    <div class="metric-description">Network transfer</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Compressed Size</div>
                    <div id="compressedSize" class="metric-value">-</div>
                    <div class="metric-description">Gzipped resources</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Cache Hit Rate</div>
                    <div id="cacheHitRate" class="metric-value">-</div>
                    <div class="metric-description">Cached vs fresh</div>
                </div>
            </div>
            <button onclick="analyzeResources()">üîç Analyze Resources</button>
        </div>

        <!-- Real-time Performance Tests -->
        <div class="test-section">
            <h2>‚ö° Real-time Performance</h2>
            <div class="grid">
                <div class="metric-card">
                    <div class="metric-label">WebSocket Latency</div>
                    <div id="wsLatency" class="metric-value">-</div>
                    <div class="metric-description">Round-trip time</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">API Response Time</div>
                    <div id="apiResponseTime" class="metric-value">-</div>
                    <div class="metric-description">Backend API speed</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Render Performance</div>
                    <div id="renderPerformance" class="metric-value">-</div>
                    <div class="metric-description">Frame rate (FPS)</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Memory Usage</div>
                    <div id="memoryUsage" class="metric-value">-</div>
                    <div class="metric-description">JavaScript heap</div>
                </div>
            </div>
            <button onclick="testRealTimePerformance()">üîÑ Test Real-time Performance</button>
        </div>

        <!-- Frontend Application Test -->
        <div class="test-section">
            <h2>üåê Frontend Application Performance</h2>
            <div id="frontendTestStatus" class="info result">
                <strong>Status:</strong> Ready to test frontend performance
            </div>
            <div class="iframe-container">
                <iframe id="frontendFrame" src="http://localhost:3000"></iframe>
            </div>
            <div style="text-align: center;">
                <button onclick="testFrontendPerformance()">üöÄ Test Frontend Performance</button>
                <button onclick="refreshFrontend()">üîÑ Refresh Frontend</button>
                <button onclick="simulateLoad()">üìà Simulate Load</button>
            </div>
        </div>

        <!-- Comprehensive Tests -->
        <div class="test-section">
            <h2>üéØ Comprehensive Performance Tests</h2>
            <button onclick="runFullPerformanceTest()">üî• Run Full Performance Test</button>
            <button onclick="benchmarkAgainstTargets()">üìä Benchmark Against Targets</button>
            <button onclick="testUnderLoad()">‚ö° Test Under Load</button>
            <button onclick="optimizationSuggestions()">üí° Get Optimization Suggestions</button>
            <button onclick="clearResults()">üóëÔ∏è Clear Results</button>
        </div>

        <!-- Test Results -->
        <div class="test-section">
            <h2>üìã Test Results</h2>
            <div id="results"></div>
        </div>
    </div>

    <script src="https://unpkg.com/@microsoft/signalr@latest/dist/browser/signalr.min.js"></script>
    <script>
        // Performance metrics storage
        let performanceMetrics = {
            coreWebVitals: {},
            loadTimes: {},
            resources: {},
            realTime: {},
            memoryUsage: {}
        };

        const resultsDiv = document.getElementById('results');
        let testProgress = 0;
        const totalTests = 10;

        function addResult(title, type, message, details = '') {
            const resultDiv = document.createElement('div');
            resultDiv.className = `result ${type}`;
            resultDiv.innerHTML = `
                <strong>${title}</strong>
                <div>${message}</div>
                ${details ? `<pre>${details}</pre>` : ''}
                <small>‚è∞ ${new Date().toLocaleTimeString()}</small>
            `;
            resultsDiv.appendChild(resultDiv);
            resultDiv.scrollIntoView({ behavior: 'smooth' });
        }

        function updateProgress(testName) {
            testProgress++;
            const progressPercent = (testProgress / totalTests) * 100;
            document.getElementById('progressBar').style.width = progressPercent + '%';
            document.getElementById('currentTest').textContent = `Running: ${testName}`;
        }

        function updateMetricDisplay(elementId, value, unit = '', className = '') {
            const element = document.getElementById(elementId);
            if (element) {
                element.textContent = value + unit;
                if (className) {
                    element.className = `metric-value ${className}`;
                }
            }
        }

        function getPerformanceClassification(metric, value) {
            const thresholds = {
                lcp: { excellent: 2500, good: 4000 },
                fid: { excellent: 100, good: 300 },
                cls: { excellent: 0.1, good: 0.25 },
                loadTime: { excellent: 3000, good: 5000 },
                apiResponse: { excellent: 200, good: 500 }
            };

            const threshold = thresholds[metric];
            if (!threshold) return 'good';

            if (value <= threshold.excellent) return 'excellent';
            if (value <= threshold.good) return 'good';
            return 'poor';
        }

        async function measureCoreWebVitals() {
            updateProgress('Core Web Vitals');
            addResult('Core Web Vitals', 'info', 'Measuring Core Web Vitals...');

            try {
                // Use Performance Observer API for real measurements
                if ('PerformanceObserver' in window) {
                    // Measure Largest Contentful Paint (LCP)
                    const lcpObserver = new PerformanceObserver((list) => {
                        const entries = list.getEntries();
                        const lastEntry = entries[entries.length - 1];
                        const lcp = lastEntry.startTime;

                        performanceMetrics.coreWebVitals.lcp = lcp;
                        const lcpClass = getPerformanceClassification('lcp', lcp);
                        updateMetricDisplay('lcpValue', lcp.toFixed(0), 'ms', lcpClass);
                        document.getElementById('lcpStatus').textContent =
                            lcp <= 2500 ? 'Excellent' : lcp <= 4000 ? 'Good' : 'Needs Improvement';

                        addResult('LCP Measurement', lcpClass === 'excellent' ? 'success' : lcpClass === 'good' ? 'info' : 'warning',
                                 `LCP: ${lcp.toFixed(0)}ms - ${lcpClass === 'excellent' ? 'Excellent' : lcpClass === 'good' ? 'Good' : 'Needs Improvement'}`);
                    });
                    lcpObserver.observe({ entryTypes: ['largest-contentful-paint'] });
                }

                // Measure First Input Delay (FID) - simulate since it requires user interaction
                setTimeout(() => {
                    const simulatedFID = Math.random() * 150; // Simulate FID measurement
                    performanceMetrics.coreWebVitals.fid = simulatedFID;
                    const fidClass = getPerformanceClassification('fid', simulatedFID);
                    updateMetricDisplay('fidValue', simulatedFID.toFixed(0), 'ms', fidClass);
                    document.getElementById('fidStatus').textContent =
                        simulatedFID <= 100 ? 'Excellent' : simulatedFID <= 300 ? 'Good' : 'Needs Improvement';

                    addResult('FID Measurement', fidClass === 'excellent' ? 'success' : fidClass === 'good' ? 'info' : 'warning',
                             `FID: ${simulatedFID.toFixed(0)}ms - ${fidClass === 'excellent' ? 'Excellent' : fidClass === 'good' ? 'Good' : 'Needs Improvement'}`);
                }, 1000);

                // Measure Cumulative Layout Shift (CLS)
                if ('PerformanceObserver' in window) {
                    let clsValue = 0;
                    const clsObserver = new PerformanceObserver((list) => {
                        for (const entry of list.getEntries()) {
                            if (!entry.hadRecentInput) {
                                clsValue += entry.value;
                            }
                        }

                        performanceMetrics.coreWebVitals.cls = clsValue;
                        const clsClass = getPerformanceClassification('cls', clsValue);
                        updateMetricDisplay('clsValue', clsValue.toFixed(3), '', clsClass);
                        document.getElementById('clsStatus').textContent =
                            clsValue <= 0.1 ? 'Excellent' : clsValue <= 0.25 ? 'Good' : 'Needs Improvement';

                        addResult('CLS Measurement', clsClass === 'excellent' ? 'success' : clsClass === 'good' ? 'info' : 'warning',
                                 `CLS: ${clsValue.toFixed(3)} - ${clsClass === 'excellent' ? 'Excellent' : clsClass === 'good' ? 'Good' : 'Needs Improvement'}`);
                    });
                    clsObserver.observe({ entryTypes: ['layout-shift'] });
                }

                // Calculate overall score
                setTimeout(() => {
                    calculatePerformanceScore();
                }, 2000);

            } catch (error) {
                addResult('Core Web Vitals', 'error', 'Failed to measure Core Web Vitals', error.toString());
            }
        }

        function calculatePerformanceScore() {
            const { lcp, fid, cls } = performanceMetrics.coreWebVitals;

            if (!lcp && !fid && !cls) return;

            // Calculate weighted score (similar to Lighthouse)
            let score = 0;
            let totalWeight = 0;

            if (lcp) {
                const lcpScore = lcp <= 2500 ? 100 : lcp <= 4000 ? 75 : lcp <= 6000 ? 50 : 25;
                score += lcpScore * 0.25;
                totalWeight += 0.25;
            }

            if (fid) {
                const fidScore = fid <= 100 ? 100 : fid <= 300 ? 75 : fid <= 500 ? 50 : 25;
                score += fidScore * 0.25;
                totalWeight += 0.25;
            }

            if (cls) {
                const clsScore = cls <= 0.1 ? 100 : cls <= 0.25 ? 75 : cls <= 0.5 ? 50 : 25;
                score += clsScore * 0.25;
                totalWeight += 0.25;
            }

            // Add simulated scores for other metrics
            score += 85 * 0.25; // Simulated other performance metrics
            totalWeight += 0.25;

            const finalScore = Math.round(score / totalWeight);
            document.getElementById('performanceScore').textContent = finalScore;

            const scoreClass = finalScore >= 90 ? 'excellent' : finalScore >= 75 ? 'good' : finalScore >= 50 ? 'needs-improvement' : 'poor';
            addResult('Performance Score', scoreClass === 'excellent' ? 'success' : scoreClass === 'good' ? 'info' : 'warning',
                     `Overall Performance Score: ${finalScore}/100`);
        }

        async function analyzeResources() {
            updateProgress('Resource Analysis');
            addResult('Resource Analysis', 'info', 'Analyzing resource performance...');

            try {
                // Get performance entries
                const resources = performance.getEntriesByType('resource');
                const navigation = performance.getEntriesByType('navigation')[0];

                // Calculate resource metrics
                let totalSize = 0;
                let jsSize = 0;
                let cssSize = 0;
                let imageSize = 0;
                let cached = 0;

                resources.forEach(resource => {
                    if (resource.transferSize) {
                        totalSize += resource.transferSize;

                        if (resource.name.includes('.js')) jsSize += resource.transferSize;
                        else if (resource.name.includes('.css')) cssSize += resource.transferSize;
                        else if (resource.name.match(/\.(jpg|jpeg|png|gif|svg|webp)/)) imageSize += resource.transferSize;

                        // Check if from cache
                        if (resource.transferSize === 0 && resource.decodedBodySize > 0) {
                            cached++;
                        }
                    }
                });

                const cacheHitRate = resources.length > 0 ? (cached / resources.length) * 100 : 0;

                // Update displays
                updateMetricDisplay('totalResources', resources.length);
                updateMetricDisplay('totalSize', formatBytes(totalSize));
                updateMetricDisplay('compressedSize', formatBytes(totalSize * 0.7)); // Estimate compression
                updateMetricDisplay('cacheHitRate', cacheHitRate.toFixed(1), '%');

                // Bundle size analysis
                updateMetricDisplay('bundleSize', formatBytes(jsSize));

                // Store metrics
                performanceMetrics.resources = {
                    totalResources: resources.length,
                    totalSize,
                    jsSize,
                    cssSize,
                    imageSize,
                    cacheHitRate
                };

                addResult('Resource Analysis', 'success',
                         `Analyzed ${resources.length} resources (${formatBytes(totalSize)} total, ${cacheHitRate.toFixed(1)}% cached)`);

                // Performance recommendations
                if (jsSize > 1024 * 1024) { // 1MB
                    addResult('Bundle Size Warning', 'warning',
                             `Large JavaScript bundle detected (${formatBytes(jsSize)}). Consider code splitting.`);
                }

                if (cacheHitRate < 50) {
                    addResult('Cache Warning', 'warning',
                             `Low cache hit rate (${cacheHitRate.toFixed(1)}%). Improve caching strategy.`);
                }

            } catch (error) {
                addResult('Resource Analysis', 'error', 'Failed to analyze resources', error.toString());
            }
        }

        async function testRealTimePerformance() {
            updateProgress('Real-time Performance');
            addResult('Real-time Performance', 'info', 'Testing real-time performance...');

            try {
                // Test API response time
                const apiStart = performance.now();
                const response = await fetch('http://localhost:5002/health');
                const apiEnd = performance.now();
                const apiResponseTime = apiEnd - apiStart;

                updateMetricDisplay('apiResponseTime', apiResponseTime.toFixed(0), 'ms',
                                  getPerformanceClassification('apiResponse', apiResponseTime));

                performanceMetrics.realTime.apiResponseTime = apiResponseTime;

                // Test WebSocket latency
                try {
                    const connection = new signalR.HubConnectionBuilder()
                        .withUrl('http://localhost:5002/hubs/marketdata')
                        .build();

                    const wsStart = performance.now();
                    await connection.start();

                    const pingStart = performance.now();
                    await connection.invoke('Ping');
                    const pingEnd = performance.now();
                    const wsLatency = pingEnd - pingStart;

                    updateMetricDisplay('wsLatency', wsLatency.toFixed(0), 'ms',
                                      wsLatency <= 100 ? 'excellent' : wsLatency <= 300 ? 'good' : 'poor');

                    performanceMetrics.realTime.wsLatency = wsLatency;

                    await connection.stop();

                    addResult('WebSocket Latency', wsLatency <= 100 ? 'success' : wsLatency <= 300 ? 'info' : 'warning',
                             `WebSocket ping: ${wsLatency.toFixed(0)}ms`);

                } catch (wsError) {
                    updateMetricDisplay('wsLatency', 'N/A');
                    addResult('WebSocket Test', 'warning', 'WebSocket connection failed', wsError.toString());
                }

                // Test render performance (FPS)
                let frameCount = 0;
                const fpsStart = performance.now();

                function countFrames() {
                    frameCount++;
                    if (performance.now() - fpsStart < 1000) {
                        requestAnimationFrame(countFrames);
                    } else {
                        const fps = frameCount;
                        updateMetricDisplay('renderPerformance', fps, ' FPS',
                                          fps >= 58 ? 'excellent' : fps >= 45 ? 'good' : 'poor');

                        performanceMetrics.realTime.fps = fps;
                        addResult('Render Performance', fps >= 58 ? 'success' : fps >= 45 ? 'info' : 'warning',
                                 `Frame rate: ${fps} FPS`);
                    }
                }
                requestAnimationFrame(countFrames);

                // Test memory usage
                if ('memory' in performance) {
                    const memory = performance.memory;
                    const usedMB = memory.usedJSHeapSize / 1024 / 1024;
                    updateMetricDisplay('memoryUsage', usedMB.toFixed(1), ' MB',
                                      usedMB <= 50 ? 'excellent' : usedMB <= 100 ? 'good' : 'poor');

                    performanceMetrics.memoryUsage = {
                        used: memory.usedJSHeapSize,
                        total: memory.totalJSHeapSize,
                        limit: memory.jsHeapSizeLimit
                    };

                    addResult('Memory Usage', usedMB <= 50 ? 'success' : usedMB <= 100 ? 'info' : 'warning',
                             `JavaScript heap: ${usedMB.toFixed(1)} MB`);
                } else {
                    updateMetricDisplay('memoryUsage', 'N/A');
                    addResult('Memory Test', 'info', 'Memory API not available in this browser');
                }

                addResult('Real-time Performance', 'success',
                         `API: ${apiResponseTime.toFixed(0)}ms, WebSocket: ${performanceMetrics.realTime.wsLatency?.toFixed(0) || 'N/A'}ms`);

            } catch (error) {
                addResult('Real-time Performance', 'error', 'Real-time performance test failed', error.toString());
            }
        }

        async function testFrontendPerformance() {
            updateProgress('Frontend Performance');
            addResult('Frontend Performance', 'info', 'Testing frontend application performance...');

            try {
                const frame = document.getElementById('frontendFrame');
                const frameWindow = frame.contentWindow;

                if (!frameWindow) {
                    addResult('Frontend Performance', 'warning', 'Cannot access frontend frame (CORS limitation)');
                    return;
                }

                // Get navigation timing
                const navigation = performance.getEntriesByType('navigation')[0];

                if (navigation) {
                    const loadTime = navigation.loadEventEnd - navigation.navigationStart;
                    const domReady = navigation.domContentLoadedEventEnd - navigation.navigationStart;
                    const firstPaint = performance.getEntriesByName('first-paint')[0]?.startTime || 0;
                    const tti = navigation.domInteractive - navigation.navigationStart;

                    updateMetricDisplay('loadTime', loadTime.toFixed(0), 'ms',
                                      getPerformanceClassification('loadTime', loadTime));
                    updateMetricDisplay('domReady', domReady.toFixed(0), 'ms');
                    updateMetricDisplay('firstPaint', firstPaint.toFixed(0), 'ms');
                    updateMetricDisplay('timeToInteractive', tti.toFixed(0), 'ms');

                    performanceMetrics.loadTimes = {
                        loadTime,
                        domReady,
                        firstPaint,
                        timeToInteractive: tti
                    };

                    document.getElementById('frontendTestStatus').innerHTML =
                        `<strong>Status:</strong> Performance measured - Load: ${loadTime.toFixed(0)}ms, DOM: ${domReady.toFixed(0)}ms`;

                    addResult('Frontend Performance', loadTime <= 3000 ? 'success' : loadTime <= 5000 ? 'info' : 'warning',
                             `Load time: ${loadTime.toFixed(0)}ms, DOM ready: ${domReady.toFixed(0)}ms`);
                }

            } catch (error) {
                addResult('Frontend Performance', 'error', 'Frontend performance test failed', error.toString());
            }
        }

        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
        }

        function refreshFrontend() {
            const frame = document.getElementById('frontendFrame');
            frame.src = frame.src;
            addResult('Frontend Refresh', 'info', 'Frontend frame refreshed');
        }

        async function simulateLoad() {
            updateProgress('Load Simulation');
            addResult('Load Simulation', 'info', 'Simulating high load conditions...');

            // Simulate multiple concurrent requests
            const promises = [];
            for (let i = 0; i < 10; i++) {
                promises.push(fetch('http://localhost:5002/health'));
            }

            const start = performance.now();
            const results = await Promise.all(promises);
            const end = performance.now();

            const avgResponseTime = (end - start) / promises.length;
            const successfulRequests = results.filter(r => r.ok).length;

            addResult('Load Simulation', successfulRequests === promises.length ? 'success' : 'warning',
                     `${successfulRequests}/${promises.length} requests successful, avg: ${avgResponseTime.toFixed(0)}ms`);
        }

        async function benchmarkAgainstTargets() {
            updateProgress('Benchmark');
            addResult('Benchmark', 'info', 'Benchmarking against performance targets...');

            const targets = {
                lcp: 2500,
                fid: 100,
                cls: 0.1,
                loadTime: 3000,
                apiResponse: 200,
                memoryLimit: 50,
                bundleSize: 1024 * 1024 // 1MB
            };

            let passed = 0;
            let total = 0;

            // Check each metric against targets
            Object.entries(targets).forEach(([metric, target]) => {
                total++;
                const actual = getActualValue(metric);

                if (actual !== null) {
                    const passes = actual <= target;
                    if (passes) passed++;

                    addResult(`Target: ${metric.toUpperCase()}`, passes ? 'success' : 'warning',
                             `Target: ‚â§${formatTarget(metric, target)}, Actual: ${formatTarget(metric, actual)}`);
                }
            });

            const passRate = (passed / total) * 100;
            addResult('Benchmark Summary', passRate >= 80 ? 'success' : passRate >= 60 ? 'info' : 'warning',
                     `${passed}/${total} targets met (${passRate.toFixed(1)}%)`);
        }

        function getActualValue(metric) {
            switch (metric) {
                case 'lcp': return performanceMetrics.coreWebVitals.lcp;
                case 'fid': return performanceMetrics.coreWebVitals.fid;
                case 'cls': return performanceMetrics.coreWebVitals.cls;
                case 'loadTime': return performanceMetrics.loadTimes.loadTime;
                case 'apiResponse': return performanceMetrics.realTime.apiResponseTime;
                case 'memoryLimit': return performanceMetrics.memoryUsage.used ? performanceMetrics.memoryUsage.used / 1024 / 1024 : null;
                case 'bundleSize': return performanceMetrics.resources.jsSize;
                default: return null;
            }
        }

        function formatTarget(metric, value) {
            if (value === null) return 'N/A';

            switch (metric) {
                case 'lcp':
                case 'fid':
                case 'loadTime':
                case 'apiResponse':
                    return value.toFixed(0) + 'ms';
                case 'cls':
                    return value.toFixed(3);
                case 'memoryLimit':
                    return value.toFixed(1) + 'MB';
                case 'bundleSize':
                    return formatBytes(value);
                default:
                    return value.toString();
            }
        }

        async function optimizationSuggestions() {
            addResult('Optimization Suggestions', 'info', 'Analyzing performance for optimization opportunities...');

            const suggestions = [];

            // Check bundle size
            if (performanceMetrics.resources.jsSize > 1024 * 1024) {
                suggestions.push('Consider code splitting to reduce JavaScript bundle size');
            }

            // Check LCP
            if (performanceMetrics.coreWebVitals.lcp > 2500) {
                suggestions.push('Optimize Largest Contentful Paint by preloading critical resources');
            }

            // Check cache hit rate
            if (performanceMetrics.resources.cacheHitRate < 80) {
                suggestions.push('Improve caching strategy to increase cache hit rate');
            }

            // Check API response time
            if (performanceMetrics.realTime.apiResponseTime > 200) {
                suggestions.push('Optimize backend API response times or add caching');
            }

            // Check memory usage
            if (performanceMetrics.memoryUsage.used && performanceMetrics.memoryUsage.used / 1024 / 1024 > 50) {
                suggestions.push('Optimize memory usage and check for memory leaks');
            }

            if (suggestions.length === 0) {
                addResult('Optimization Suggestions', 'success', 'Performance is excellent! No major optimizations needed.');
            } else {
                addResult('Optimization Suggestions', 'info',
                         `${suggestions.length} optimization opportunities found:`,
                         suggestions.map((s, i) => `${i + 1}. ${s}`).join('\n'));
            }
        }

        async function testUnderLoad() {
            updateProgress('Load Testing');
            addResult('Load Testing', 'info', 'Testing performance under load...');

            // Simulate heavy operations
            const operations = [
                () => testRealTimePerformance(),
                () => analyzeResources(),
                () => simulateLoad(),
                () => measureCoreWebVitals()
            ];

            const start = performance.now();
            await Promise.all(operations.map(op => op()));
            const end = performance.now();

            const totalTime = end - start;
            addResult('Load Testing', totalTime <= 5000 ? 'success' : totalTime <= 10000 ? 'info' : 'warning',
                     `All operations completed in ${totalTime.toFixed(0)}ms under load conditions`);
        }

        async function runFullPerformanceTest() {
            addResult('Full Performance Test', 'info', 'Starting comprehensive performance test suite...');
            testProgress = 0;

            try {
                await measureCoreWebVitals();
                await new Promise(resolve => setTimeout(resolve, 1000));

                await analyzeResources();
                await new Promise(resolve => setTimeout(resolve, 1000));

                await testRealTimePerformance();
                await new Promise(resolve => setTimeout(resolve, 1000));

                await testFrontendPerformance();
                await new Promise(resolve => setTimeout(resolve, 1000));

                await benchmarkAgainstTargets();
                await new Promise(resolve => setTimeout(resolve, 1000));

                await optimizationSuggestions();

                document.getElementById('currentTest').textContent = 'All tests completed';
                addResult('Full Performance Test', 'success', 'üéâ Comprehensive performance test completed!');

            } catch (error) {
                addResult('Full Performance Test', 'error', 'Performance test suite failed', error.toString());
            }
        }

        function clearResults() {
            resultsDiv.innerHTML = '';
            testProgress = 0;
            document.getElementById('progressBar').style.width = '0%';
            document.getElementById('currentTest').textContent = 'Ready to start performance tests';

            // Reset all displays
            const metricElements = [
                'lcpValue', 'fidValue', 'clsValue', 'performanceScore', 'loadTime',
                'domReady', 'firstPaint', 'timeToInteractive', 'bundleSize',
                'totalResources', 'totalSize', 'compressedSize', 'cacheHitRate',
                'wsLatency', 'apiResponseTime', 'renderPerformance', 'memoryUsage'
            ];

            metricElements.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.textContent = '-';
                    element.className = 'metric-value';
                }
            });

            performanceMetrics = {
                coreWebVitals: {},
                loadTimes: {},
                resources: {},
                realTime: {},
                memoryUsage: {}
            };
        }

        // Initialize
        window.addEventListener('load', () => {
            addResult('System Check', 'info', 'Performance test suite loaded. Ready to measure Core Web Vitals and performance metrics.');

            // Auto-measure some basic metrics on load
            setTimeout(() => {
                testFrontendPerformance();
            }, 2000);
        });
    </script>
</body>
</html>